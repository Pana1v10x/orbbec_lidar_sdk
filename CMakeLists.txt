cmake_minimum_required(VERSION 3.13)
project(orbbec_lidar_sdk VERSION 1.0.4 LANGUAGES CXX C)

# Set C++ and C standards
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)
set(CMAKE_CXX_VISIBILITY_PRESET hidden)
set(CMAKE_VISIBILITY_INLINES_HIDDEN 1)
set(CMAKE_BUILD_TYPE "Release")
set(CMAKE_INSTALL_PREFIX ${CMAKE_BINARY_DIR}/install)

if (MSVC)
    # Windows specific settings
    add_definitions(-DNOMINMAX)

    # Remove existing warning levels and set /W3 for normal warning level without treating as errors
    string(REGEX REPLACE "/W[0-4]" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
    string(REGEX REPLACE "/W[0-4]" "" CMAKE_C_FLAGS "${CMAKE_C_FLAGS}")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W3 /MP")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /W3 /MP")

    # Use static runtime library for all builds
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MT /O2 /Ob2 /DNDEBUG")
    set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} /MT /O2 /Ob2 /DNDEBUG")
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MTd /Zi /Od /Ob0 /RTC1")
    set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} /MTd /Zi /Od /Ob0 /RTC1")

    # Output debug information to confirm settings
    message(STATUS "CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}")
    message(STATUS "CMAKE_C_FLAGS: ${CMAKE_C_FLAGS}")
    message(STATUS "CMAKE_CXX_FLAGS_RELEASE: ${CMAKE_CXX_FLAGS_RELEASE}")
    message(STATUS "CMAKE_C_FLAGS_RELEASE: ${CMAKE_C_FLAGS_RELEASE}")
    message(STATUS "CMAKE_CXX_FLAGS_DEBUG: ${CMAKE_CXX_FLAGS_DEBUG}")
    message(STATUS "CMAKE_C_FLAGS_DEBUG: ${CMAKE_C_FLAGS_DEBUG}")
else ()
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fPIC -O3 -fvisibility=hidden")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC -O3 -fvisibility=hidden")
    set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -fPIC -g -O0 -fvisibility=hidden")
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -fPIC -g -O0 -fvisibility=hidden")
endif ()

# Define project options
option(BUILD_SHARED_LIBS "Build shared libraries" OFF)
option(BUILD_EXAMPLES "Build examples" ON)
option(ENABLE_TESTING "Enable testing" OFF)
option(ENABLE_SANITIZERS "Enable sanitizers" OFF)
option(ENABLE_BUILD_DOC "Enable building documentation" OFF)

# Set paths
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake")
set(THIRD_PARTY_DIR "${CMAKE_CURRENT_SOURCE_DIR}/third_party")

# Add third-party libraries
set(BUILD_UVW_LIBS ON)
set(BUILD_TESTING OFF CACHE BOOL "Disable testing for uvw" FORCE)

add_subdirectory("${THIRD_PARTY_DIR}/spdlog" EXCLUDE_FROM_ALL)
add_subdirectory("${THIRD_PARTY_DIR}/uvw" EXCLUDE_FROM_ALL)
add_subdirectory("${THIRD_PARTY_DIR}/memory" EXCLUDE_FROM_ALL)

# Find dependencies
find_package(Threads REQUIRED)
find_package(LZ4 QUIET)
find_package(ZSTD QUIET)
set(protobuf_BUILD_TESTS OFF CACHE BOOL "Build tests" FORCE)
set(protobuf_BUILD_EXAMPLES OFF CACHE BOOL "Build examples" FORCE)
set(protobuf_WITH_ZLIB OFF CACHE BOOL "Build with zlib support" FORCE)
set(protobuf_MSVC_STATIC_RUNTIME ON CACHE BOOL "Use static runtime" FORCE)

add_subdirectory("${THIRD_PARTY_DIR}/protobuf/" EXCLUDE_FROM_ALL)

set(Protobuf_INCLUDE_DIR "${THIRD_PARTY_DIR}/protobuf/src")
set(Protobuf_PROTOC_EXECUTABLE "${CMAKE_BINARY_DIR}/protobuf-prefix/src/protobuf-build/protoc")
set(Protobuf_LIBRARIES libprotobuf)
set(Protobuf_FOUND TRUE)

# debug
message(STATUS "Protobuf_INCLUDE_DIR: ${Protobuf_INCLUDE_DIR}")
message(STATUS "Protobuf_PROTOC_EXECUTABLE: ${Protobuf_PROTOC_EXECUTABLE}")
message(STATUS "Protobuf_LIBRARIES: ${Protobuf_LIBRARIES}")

file(GLOB all_protos "proto/foxglove/*.proto")

foreach (f ${all_protos})
    file(RELATIVE_PATH f ${CMAKE_CURRENT_SOURCE_DIR}/proto ${f})
    string(REGEX REPLACE "\\.proto$" "" f ${f})
    list(APPEND proto_sources "autogenerated/${f}.pb.h")
    list(APPEND proto_sources "autogenerated/${f}.pb.cc")
endforeach (f)

add_custom_command(
        OUTPUT ${proto_sources}
        COMMAND ${CMAKE_COMMAND} -E make_directory autogenerated
        COMMAND protoc
        --proto_path=${CMAKE_CURRENT_SOURCE_DIR}/proto
        --proto_path=${THIRD_PARTY_DIR}/protobuf/src
        --cpp_out=autogenerated
        ${all_protos}
        DEPENDS protoc ${all_protos}
)
include_directories(${Protobuf_INCLUDE_DIR})
add_library(foxglove_proto_lib STATIC ${proto_sources})
target_link_libraries(foxglove_proto_lib PRIVATE ${Protobuf_LIBRARIES})
target_include_directories(foxglove_proto_lib
        PUBLIC
        ${Protobuf_INCLUDE_DIR}
        ${CMAKE_CURRENT_BINARY_DIR}/autogenerated)

# Gather source files
file(GLOB_RECURSE SRC_FILES
        "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/detail/*.cpp"
)

# Set dependencies

set(DEPENDENCIES
        spdlog::spdlog
        uvw::uvw-static
        foonathan_memory
        Threads::Threads
        foxglove_proto_lib
)

# Create library target
add_library(${PROJECT_NAME} SHARED ${SRC_FILES})
if (UNIX)
    set_target_properties(${PROJECT_NAME} PROPERTIES
            VERSION ${PROJECT_VERSION}
            SOVERSION 1
    )
endif ()

add_dependencies(${PROJECT_NAME} ${DEPENDENCIES})

if (UNIX)
    target_link_options(${PROJECT_NAME} PRIVATE
            "-Wl,--exclude-libs,ALL"
    )
endif ()

# Set include directories
target_include_directories(${PROJECT_NAME}
        PRIVATE
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src/contrib>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src/detail>
        $<BUILD_INTERFACE:${THIRD_PARTY_DIR}/mcap/cpp/mcap/include>
        $<BUILD_INTERFACE:${THIRD_PARTY_DIR}/spdlog/include>
        $<INSTALL_INTERFACE:include>
)

# Handle optional dependencies
if (LZ4_FOUND)
    list(APPEND DEPENDENCIES LZ4::LZ4)
else ()
    target_compile_definitions(${PROJECT_NAME} PUBLIC MCAP_COMPRESSION_NO_LZ4)
    message(WARNING "LZ4 not found, disabling LZ4 support")
endif ()

if (ZSTD_FOUND)
    list(APPEND DEPENDENCIES ZSTD::ZSTD)
else ()
    target_compile_definitions(${PROJECT_NAME} PUBLIC MCAP_COMPRESSION_NO_ZSTD)
    message(WARNING "ZSTD not found, disabling ZSTD support")
endif ()

# Link dependencies
target_link_libraries(${PROJECT_NAME} PRIVATE ${DEPENDENCIES})

# Enable sanitizers if option is set
if (ENABLE_SANITIZERS)
    target_compile_options(${PROJECT_NAME} PRIVATE -fsanitize=address,undefined)
    target_link_options(${PROJECT_NAME} PRIVATE -fsanitize=address,undefined)
endif ()

# Add examples if enabled
if (BUILD_EXAMPLES)
    add_subdirectory(examples)
endif ()

# Add tests if enabled
if (ENABLE_TESTING)
    include(CTest)
    add_subdirectory("${THIRD_PARTY_DIR}/googletest" EXCLUDE_FROM_ALL)
    add_subdirectory(tests)
endif ()

# Add documentation build
if (ENABLE_BUILD_DOC)
    find_package(Doxygen REQUIRED)
    if (DOXYGEN_FOUND)
        # Set input and output files
        set(DOXYGEN_IN ${CMAKE_CURRENT_SOURCE_DIR}/docs/Doxyfile.in)
        set(DOXYGEN_OUT ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile)

        # Request to configure the file
        configure_file(${DOXYGEN_IN} ${DOXYGEN_OUT} @ONLY)
        message("Doxygen build started")

        # Note the option ALL which allows to build the docs together with the application
        add_custom_target(doc_doxygen ALL
                COMMAND ${DOXYGEN_EXECUTABLE} ${DOXYGEN_OUT}
                WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
                COMMENT "Generating API documentation with Doxygen"
                VERBATIM)
    else ()
        message(WARNING "Doxygen need to be installed to generate the doxygen documentation")
    endif ()
endif ()

# Installation rules
include(GNUInstallDirs)
set(INSTALL_CONFIGDIR ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME})


install(TARGETS ${PROJECT_NAME}
        EXPORT ${PROJECT_NAME}-targets
        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)


# Install the project's public headers
install(DIRECTORY include/
        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/
)

install(EXPORT ${PROJECT_NAME}-targets
        FILE ${PROJECT_NAME}-targets.cmake
        DESTINATION ${INSTALL_CONFIGDIR}
)

install(EXPORT ${PROJECT_NAME}-targets
        FILE ${PROJECT_NAME}-targets.cmake
        DESTINATION ${INSTALL_CONFIGDIR}
)

# Create a ConfigVersion.cmake file
include(CMakePackageConfigHelpers)
write_basic_package_version_file(
        ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake
        VERSION ${PROJECT_VERSION}
        COMPATIBILITY AnyNewerVersion
)

configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/cmake/${PROJECT_NAME}-config.cmake.in
        ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config.cmake
        INSTALL_DESTINATION ${INSTALL_CONFIGDIR}
)

# Install the config files
install(FILES
        ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config.cmake
        ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake
        DESTINATION ${INSTALL_CONFIGDIR}
)
# include uninstall target
if (NOT TARGET uninstall)
    configure_file(
            "${CMAKE_CURRENT_SOURCE_DIR}/cmake/cmake_uninstall.cmake.in"
            "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
            IMMEDIATE @ONLY)
    add_custom_target(uninstall COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)
endif ()
